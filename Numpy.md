

#### 1차원 배열
vec = np.array([1, 2, 3, 4, 5])
출력: [1 2 3 4 5]

#### 2차원 배열
mat = np.array([[10, 20, 30], [ 60, 70, 80]]) 

출력: [[10 20 30]
 [60 70 80]]

arr1 = np.array([1, 2, 3, 4, 5]) # 1차원 배열 생성
arr2 = np.array([[1, 2, 3], [4, 5, 6]]) # 2차원 배열 생성

arr.shape # 배열의 크기를 반환합니다. (행의 수, 열의 수 등)
arr.dtype # 배열의 데이터 타입을 확인합니다.
arr.ndim # 배열의 차원 수를 확인합니다.
arr.size # 배열의 총 요소 수를 반환합니다.

arr_sum = arr1 + arr1 # 배열 간의 연산





[1 2 3 4 5]
`vec`와 `mat`은 각각 1차원 배열과 2차원 배열을 나타내는 데 사용되는 일반적인 용어입니다. 

1. **vec (벡터)**:
   - `vec`는 보통 1차원 Numpy 배열을 의미합니다. 예를 들어, \(`vec = np.array([1, 2, 3])`\)와 같은 배열은 하나의 축만을 가지고 있으며, 요소의 개수에 따라 크기가 결정됩니다.
   - 벡터는 주로 특성(feature) 벡터나 입력 데이터의 표현으로 사용됩니다.

2. **mat (행렬)**:
   - `mat`은 2차원 Numpy 배열을 의미합니다. 예를 들어, \(`mat = np.array([[1, 2], [3, 4]])`\)와 같은 배열은 두 개의 축을 가지며, 행과 열의 개수에 따라 크기가 결정됩니다.
   - 행렬은 데이터의 배치(batch)나 여러 개의 특성을 동시에 표현할 때 사용됩니다.

딥러닝에서는 벡터는 주로 개별 데이터 포인트를 나타내고, 행렬은 여러 데이터 포인트를 동시에 처리하기 위해 사용됩니다. 각 차원에 대한 이해는 모델의 입력과 구조를 설정하는 데 필수적입니다.

Numpy 배열에서 축의 개수(ndim)와 크기(shape)는 배열의 구조와 데이터의 배치를 이해하는 데 중요한 개념입니다. 

1. **축의 개수 (ndim)**:
   - 배열의 축의 개수는 배열이 몇 차원인지를 나타냅니다. 예를 들어:
     - 1D 배열: 벡터 (예: \([1, 2, 3]\))는 1개의 축을 가집니다.
     - 2D 배열: 행렬 (예: \([[1, 2], [3, 4]]\))은 2개의 축을 가집니다.
     - 3D 배열: 텐서 (예: 여러 행렬을 쌓은 것)는 3개의 축을 가집니다.
   - 딥러닝에서는 데이터의 차원에 따라 모델의 입력 형태를 정의하는 데 중요합니다.

2. **크기 (shape)**:
   - 배열의 크기는 각 축의 크기를 나타내는 튜플입니다. 예를 들어:
     - 1D 배열의 크기는 \((n,)\)로, \(n\)은 요소의 개수입니다.
     - 2D 배열의 크기는 \((m, n)\)으로, \(m\)은 행의 수, \(n\)은 열의 수입니다.
     - 3D 배열의 크기는 \((d1, d2, d3)\)로, 각 차원에 대한 크기를 나타냅니다.
   - 딥러닝에서는 배치 크기, 채널 수, 이미지 크기 등을 정의할 때 이 크기가 중요합니다.

이 두 개념을 이해하면 데이터 전처리, 모델 설계, 그리고 입력 데이터를 올바르게 변환하는 데 큰 도움이 됩니다.


# 모든 값이 0인 2x3 배열 생성.
zero_mat = np.zeros((2,3))

[[0. 0. 0.]
 [0. 0. 0.]]


 # 모든 값이 1인 2x3 배열 생성.
one_mat = np.ones((2,3))

[[1. 1. 1.]
 [1. 1. 1.]]

 # 모든 값이 특정 상수인 배열 생성. 이 경우 7.
same_value_mat = np.full((2,2), 7)
print(same_value_mat)

[[7 7]
 [7 7]]


eye_mat = np.eye(3)

[[1. 0. 0.]
 [0. 1. 0.]]
 [0. 0. 1.]]

 # 임의의 값으로 채워진 배열 생성
random_mat = np.random.random((2,2)) # 임의의 값으로 채워진 배열 생성

[[0.3111881  0.72996102]
 [0.65667734 0.40758328]]


 # 0부터 9까지
range_vec = np.arange(10)

[0 1 2 3 4 5 6 7 8 9]

# 1부터 9까지 +2씩 적용되는 범위
n = 2
range_n_step_vec = np.arange(1, 10, n)

[1 3 5 7 9]

# 0부터 29까지의 숫자를 생성하는 arange(30)을 수행한 후, 원소의 개수가 30개이므로 5행 6열의 행렬로 변경

reshape_mat = np.array(np.arange(30)).reshape((5,6))

[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]
 [24 25 26 27 28 29]]


# 리스트처럼 슬라이싱(slicing) 기능

 mat = np.array([[1, 2, 3], [4, 5, 6]])

 [[1 2 3]
 [4 5 6]]

slicing_mat = mat[0, :]

[1 2 3]

slicing_mat = mat[:, 1]

[2 5]

# 정수 인덱싱(integer indexing)

mat = np.array([[1, 2], [4, 5], [7, 8]])

[[1 2]
 [4 5]
 [7 8]]

# 1행 0열의 원소
# => 0부터 카운트하므로 두번째 행 첫번째 열의 원소.
mat[1, 0]

4

# mat[[2행, 1행],[0열, 1열]]
# 각 행과 열의 쌍을 매칭하면 2행 0열, 1행 1열의 두 개의 원소.
indexing_mat = mat[[2, 1],[0, 1]]



 Numpy 연산

x = np.array([1,2,3])
y = np.array([4,5,6])

# result = np.add(x, y)와 동일.
result = x + y

[5 7 9]

# result = np.subtract(x, y)와 동일.
result = x - y

[-3 -3 -3]

# result = np.multiply(result, x)와 동일.
result = result * x

[-3 -6 -9]

# result = np.divide(result, x)와 동일.
result = result / x

[-3. -3. -3.]

# 행렬곱 또는 행렬곱을 위해서는 dot()을 사용해야 합니다.

mat1 = np.array([[1,2],[3,4]])
mat2 = np.array([[5,6],[7,8]])
mat3 = np.dot(mat1, mat2)

[[19 22]
 [43 50]]
